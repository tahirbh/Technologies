<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Solar System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #00ff00;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        /* Navigation Overlay */
#nav-hud {
    position: absolute;
    top: 50%;
    right: 20px;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 15px;
    z-index: 1000;
}

.nav-link {
    background: rgba(0, 20, 0, 0.8);
    border: 1px solid #00ff00;
    color: #00ff00;
    padding: 15px;
    text-decoration: none;
    font-size: 12px;
    transition: all 0.3s;
    text-transform: uppercase;
    letter-spacing: 2px;
    writing-mode: vertical-rl;
    text-orientation: mixed;
}

.nav-link:hover {
    background: #00ff00;
    color: #000;
    box-shadow: 0 0 20px #00ff00;
}
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Top Panel - Matrix typing display */
        #info-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 800px;
            border: 0px ;
            padding: 20px;
            
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #info-panel.visible {
            opacity: 1;
        }

        #planet-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #00ff00;
            letter-spacing: 3px;
        }

        #planet-description {
            font-size: 16px;
            line-height: 1.6;
            min-height: 60px;
        }

        .cursor {
            display: inline-block;
            width: 8px;
            height: 18px;
            background: #00ff00;
            animation: blink 1s infinite;
            margin-left: 2px;
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        /* Bottom Stats Panel */
        #stats-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 1000px;
            border: 0px ;
            padding: 15px 20px;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            gap: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            flex: 1;
            min-width: 150px;
            text-align: center;
            padding: 10px;
            border-right: 2px dashed #00ff00;
        }

        .stat-item:last-child {
            border-right: none;
        }

        .stat-label {
            font-size: 11px;
            opacity: 0.7;
            margin-bottom: 5px;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 8px #00ff00;
        }

        /* Loading screen */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 200;
            transition: opacity 0.5s ease;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ff00;
        }

        .loading-bar {
            width: 300px;
            height: 4px;
            background: #003300;
            border: 1px solid #00ff00;
            overflow: hidden;
        }

        .loading-progress {
            width: 0%;
            height: 100%;
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
            animation: loading 2s ease-in-out forwards;
        }

        @keyframes loading {
            to { width: 100%; }
        }

        /* Responsive */
        @media (max-width: 768px) {
            #info-panel {
                width: 95%;
                padding: 15px;
            }

            #planet-title {
                font-size: 18px;
            }

            #planet-description {
                font-size: 14px;
                min-height: 50px;
            }

            #stats-panel {
                width: 95%;
                padding: 10px 15px;
                gap: 10px;
            }

            .stat-item {
                min-width: 100px;
                padding: 8px;
            }

            .stat-label {
                font-size: 9px;
            }

            .stat-value {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loading-text">INITIALIZING SOLAR SYSTEM...</div>
        <div class="loading-bar">
            <div class="loading-progress"></div>
        </div>
    </div>
<nav id="nav-hud">
    <a href="/" class="nav-link">System Overview</a>
    <a href="Page2.html" class="nav-link">Seasonal Physics</a>
    <a href="page3.html" class="nav-link">Earth Matrix</a>
</nav>
    <div id="canvas-container"></div>

    <!-- Top Info Panel -->
    <div id="info-panel">
        <div id="planet-title">‚òÄÔ∏è SOLAR SYSTEM</div>
        <div id="planet-description">Hover over a planet to view information...</div>
    </div>

    <!-- Bottom Stats Panel -->
    <div id="stats-panel">
        <div class="stat-item">
            <div class="stat-label">LOCAL TIME</div>
            <div class="stat-value" id="local-time">--:--:--</div>
        </div>
        <div class="stat-item">
            <div class="stat-label"></div>
            <div class="stat-value" id="ip-address"></div>
        </div>
        <div class="stat-item">
            <div class="stat-label"></div>
            <div class="stat-value"></div>
        </div>
        <div class="stat-item">
            <div class="stat-label">ZOOM LEVEL</div>
            <div class="stat-value" id="zoom-level">100%</div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Camera position
        camera.position.set(0, 50, 150);

        // OrbitControls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 30;
        controls.maxDistance = 500;
        controls.enablePan = true;

        // Raycaster for planet picking
        const raycaster = new THREE.Raycaster();
        raycaster.params.Points.threshold = 2;
        const mouse = new THREE.Vector2();
        let hoveredPlanet = null;
        let typingTimeout = null;

        // Planet data with emojis
        const planetData = {
            mercury: { emoji: '‚òøÔ∏è', name: 'MERCURY', description: 'Closest to sun. Extreme temps. Heavily cratered.' },
            venus: { emoji: '‚ôÄÔ∏è', name: 'VENUS', description: 'Acid clouds. Hottest planet. Retrograde rotation.' },
            earth: { emoji: 'üåç', name: 'EARTH', description: 'The Blue Marble. Only known life. 71% water.' },
            mars: { emoji: '‚ôÇÔ∏è', name: 'MARS', description: 'Iron oxide. Largest volcano. Ancient water.' },
            jupiter: { emoji: '‚ôÉ', name: 'JUPITER', description: 'Largest. Great Red Spot storm. 79 moons.' },
            saturn: { emoji: '‚ôÑ', name: 'SATURN', description: 'Ice-rock rings. Low density. 82 moons.' },
            uranus: { emoji: '‚ôÖ', name: 'URANUS', description: 'Rotates sideways. Faint rings. Coldest.' },
            neptune: { emoji: '‚ôÜ', name: 'NEPTUNE', description: 'Supersonic winds. Dark Spot. Triton moon.' }
        };

        // Create canvas textures
        function createPlanetTexture(color, hasSpot = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Base color
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 512, 512);

            // Add some texture variation
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = `rgba(${Math.random() * 50}, ${Math.random() * 50}, ${Math.random() * 50}, 0.3)`;
                ctx.fillRect(Math.random() * 512, Math.random() * 512, Math.random() * 100, Math.random() * 100);
            }

            // Jupiter's Great Red Spot
            if (hasSpot) {
                const gradient = ctx.createRadialGradient(300, 256, 20, 300, 256, 60);
                gradient.addColorStop(0, 'rgba(200, 50, 50, 0.9)');
                gradient.addColorStop(1, 'rgba(150, 40, 40, 0.3)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(300, 256, 60, 40, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
        }

        // Create Sun
        const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
            color: 0xff6600,
            emissive: 0xff4400,
            emissiveIntensity: 1
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);

        // Sun glow sprite
        const spriteMaterial = new THREE.SpriteMaterial({
            map: createGlowTexture(),
            color: 0xff6600,
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        const sunGlow = new THREE.Sprite(spriteMaterial);
        sunGlow.scale.set(40, 40, 1);
        sun.add(sunGlow);

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 150, 50, 0.8)');
            gradient.addColorStop(0.4, 'rgba(255, 100, 0, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            return new THREE.CanvasTexture(canvas);
        }

        // Planet configurations
        const planets = [];
        const planetConfigs = [
            { name: 'mercury', size: 1.5, distance: 25, color: '#8c7853', speed: 0.04 },
            { name: 'venus', size: 2.3, distance: 35, color: '#ffc649', speed: 0.03 },
            { name: 'earth', size: 2.5, distance: 50, color: '#4169e1', speed: 0.02 },
            { name: 'mars', size: 2, distance: 65, color: '#cd5c5c', speed: 0.018 },
            { name: 'jupiter', size: 5, distance: 100, color: '#daa520', speed: 0.01, hasSpot: true },
            { name: 'saturn', size: 4.5, distance: 140, color: '#f4a460', speed: 0.008, hasRings: true },
            { name: 'uranus', size: 3.5, distance: 180, color: '#4fd0e7', speed: 0.006 },
            { name: 'neptune', size: 3.5, distance: 220, color: '#4169e1', speed: 0.005 }
        ];

        planetConfigs.forEach(config => {
            // Planet mesh
            const geometry = new THREE.SphereGeometry(config.size, 32, 32);
            const texture = createPlanetTexture(config.color, config.hasSpot);
            const material = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.7,
                metalness: 0.3
            });
            const planet = new THREE.Mesh(geometry, material);
            planet.userData.name = config.name;
            planet.userData.distance = config.distance;
            planet.userData.speed = config.speed;
            planet.userData.angle = Math.random() * Math.PI * 2;
            planet.userData.rotationSpeed = 0.01 + Math.random() * 0.02;
            
            scene.add(planet);
            planets.push(planet);

            // Orbit lines
            const orbitGeometry = new THREE.BufferGeometry();
            const orbitPoints = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                orbitPoints.push(
                    Math.cos(angle) * config.distance,
                    0,
                    Math.sin(angle) * config.distance
                );
            }
            orbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(orbitPoints, 3));
            
            const orbitMaterial = new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.6 });
            const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
            scene.add(orbit);

            // Secondary orbit line for depth
            const orbitGeometry2 = new THREE.BufferGeometry();
            const orbitPoints2 = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                orbitPoints2.push(
                    Math.cos(angle) * config.distance * 1.02,
                    0,
                    Math.sin(angle) * config.distance * 1.02
                );
            }
            orbitGeometry2.setAttribute('position', new THREE.Float32BufferAttribute(orbitPoints2, 3));
            const orbitMaterial2 = new THREE.LineBasicMaterial({ color: 0x555555, transparent: true, opacity: 0.3 });
            const orbit2 = new THREE.Line(orbitGeometry2, orbitMaterial2);
            scene.add(orbit2);

            // Saturn's rings
            if (config.hasRings) {
                const ringGeometry = new THREE.RingGeometry(config.size * 1.5, config.size * 2.5, 64);
                const ringTexture = createRingTexture();
                const ringMaterial = new THREE.MeshBasicMaterial({
                    map: ringTexture,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                const rings = new THREE.Mesh(ringGeometry, ringMaterial);
                rings.rotation.x = Math.PI / 2;
                rings.rotation.y = Math.PI / 6;
                planet.add(rings);
            }
        });

        function createRingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            for (let i = 0; i < 512; i++) {
                const alpha = Math.sin(i / 512 * Math.PI * 10) * 0.3 + 0.5;
                ctx.strokeStyle = `rgba(180, 150, 120, ${alpha})`;
                ctx.beginPath();
                ctx.arc(256, 256, i / 2, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            return new THREE.CanvasTexture(canvas);
        }

        // Starfield
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        for (let i = 0; i < 10000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            starVertices.push(x, y, z);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 1.5,
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 2, 500);
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);

        // Matrix typing animation
        function typeText(text, element) {
            element.innerHTML = '';
            let index = 0;
            
            clearTimeout(typingTimeout);
            
            function type() {
                if (index < text.length) {
                    element.innerHTML = text.substring(0, index + 1) + '<span class="cursor"></span>';
                    index++;
                    typingTimeout = setTimeout(type, 30);
                } else {
                    element.innerHTML = text;
                }
            }
            
            type();
        }

        // Mouse/Touch interaction
        function onPointerMove(event) {
            event.preventDefault();
            const rect = renderer.domElement.getBoundingClientRect();
            let x, y;
            
            if (event.touches && event.touches[0]) {
                x = event.touches[0].clientX;
                y = event.touches[0].clientY;
            } else {
                x = event.clientX;
                y = event.clientY;
            }
            
            mouse.x = ((x - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((y - rect.top) / rect.height) * 2 + 1;

            checkPlanetIntersection();
        }

        function checkPlanetIntersection() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planets, true);

            if (intersects.length > 0) {
                let planet = intersects[0].object;
                // Check if we hit a child (like Saturn's rings), get parent
                while (planet.parent && !planet.userData.name) {
                    planet = planet.parent;
                }
                
                if (planet.userData.name && hoveredPlanet !== planet) {
                    hoveredPlanet = planet;
                    const data = planetData[planet.userData.name];
                    if (data) {
                        document.getElementById('planet-title').textContent = `${data.emoji} ${data.name}`;
                        typeText(data.description, document.getElementById('planet-description'));
                        document.getElementById('info-panel').classList.add('visible');
                    }
                }
            }
        }

        function onPointerClick(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const rect = renderer.domElement.getBoundingClientRect();
            let x, y;
            
            if (event.touches && event.touches[0]) {
                x = event.touches[0].clientX;
                y = event.touches[0].clientY;
            } else {
                x = event.clientX;
                y = event.clientY;
            }
            
            mouse.x = ((x - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((y - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planets, true);

            if (intersects.length > 0) {
                let planet = intersects[0].object;
                // Check if we hit a child (like Saturn's rings), get parent
                while (planet.parent && planet.parent.type !== 'Scene' && !planet.userData.name) {
                    planet = planet.parent;
                }
                
                if (planet.userData.name) {
                    hoveredPlanet = planet;
                    const data = planetData[planet.userData.name];
                    if (data) {
                        document.getElementById('planet-title').textContent = `${data.emoji} ${data.name}`;
                        typeText(data.description, document.getElementById('planet-description'));
                        document.getElementById('info-panel').classList.add('visible');
                    }
                }
            }
        }

        window.addEventListener('mousemove', onPointerMove, { passive: false });
        window.addEventListener('touchmove', onPointerMove, { passive: false });
        window.addEventListener('touchstart', onPointerClick, { passive: false });
        window.addEventListener('click', onPointerClick, { passive: false });

        // Update stats
        function updateStats() {
            // Local time
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', { hour12: false });
            document.getElementById('local-time').textContent = timeString;

            // Zoom level
            const distance = camera.position.distanceTo(controls.target);
            const zoomPercent = Math.round((1 - (distance - controls.minDistance) / (controls.maxDistance - controls.minDistance)) * 100);
            document.getElementById('zoom-level').textContent = `${Math.max(0, Math.min(100, zoomPercent))}%`;
        }

        // Generate random IP
        function generateIP() {
            const ip = `10.0.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`;
            //document.getElementById('ip-address').textContent = "ip";
        }

        generateIP();
        setInterval(updateStats, 1000);
        updateStats();

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Rotate sun
            sun.rotation.y += 0.001;

            // Rotate and orbit planets
            planets.forEach(planet => {
                planet.rotation.y += planet.userData.rotationSpeed;
                planet.userData.angle += planet.userData.speed * 0.01;
                planet.position.x = Math.cos(planet.userData.angle) * planet.userData.distance;
                planet.position.z = Math.sin(planet.userData.angle) * planet.userData.distance;
            });

            // Rotate starfield slowly
            stars.rotation.y += 0.0001;

            controls.update();
            renderer.render(scene, camera);
        }

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Hide loading screen
        setTimeout(() => {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('info-panel').classList.add('visible');
        }, 2000);

        animate();
    </script>
</body>
</html>
